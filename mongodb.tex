\chapter{MongoDB}

\begin{wrapfigure}{l}{0.4\textwidth}
  \vspace{-75pt}
  \begin{center}
    \includegraphics[width=0.38\textwidth]{mongodb.png}
  \end{center}
  \vspace{-30pt}
\end{wrapfigure}
MongoDB is part of the NoSQL family of database systems. Instead of storing data in tables as is done in a <<classical>> relational database, MongoDB stores structured data as JSON-like documents with dynamic schemas (MongoDB calls the format BSON), making the integration of data in certain types of applications easier and faster.

\section{Short specification}

\begin{itemize}
  \item \textbf{Written in:} C++
  \item \textbf{Main point:} Retains some friendly properties of SQL. (Query, index)
  \item \textbf{License:} GNU AGPL v3.0 (drivers: Apache license)
  \item \textbf{Protocol:} Custom, binary (BSON), HTTP/REST
  \item \textbf{Web site:} \href{http://www.mongodb.org/}{www.mongodb.org}
\end{itemize}

\section{Main features}

\begin{figure}[hb]
  \centering
  \includegraphics[width=1\textwidth]{mongodb_web_scale.jpeg}
\end{figure}

\section{Strengths}

Mongo's primary strength lies in its ability to handle huge amounts of data (and huge amounts of requests) by replication and horizontal scaling. But it also has an added benefit of a very flexible data model, since you needn’t ever conform to a schema and can simply nest any values you would generally join using SQL in an RDBMS anyway.

Finally, MongoDB was built to be easy to use. You may have noticed the similarity between Mongo commands and SQL database concepts (minus the server-side joins). This is not by accident and is one reason Mongo is gaining so much mind share from former object-relational model (ORM) users. It’s different enough to scratch a lot of developer itches but not so different it becomes a wholly different and scary monster.\cite{seven_databases}

\section{Weaknesses}

How Mongo encourages denormalization of schemas (by not having any) might be a bit too much for some to swallow. Some developers find the cold, hard constraints of a relational database reassuring. It can be dangerous to insert any old value of any type into any collection. A single typo can cause hours of headache if you don’t think to look at field names and collection names as a possible culprit. Mongo’s flexibility is generally not important if your data model is already fairly mature and locked down.

Because Mongo is focused on large datasets, it works best in large clusters, which can require some effort to design and manage. Unlike Riak, where adding new nodes is transparent and relatively painless for operations, setting up a Mongo cluster requires a little more forethought.\cite{seven_databases}

\section{Tips}

\subsection{Compact databases with repair}

Command <<repair>> (use for repair data in database) can be used to compact databases. <<repair>> basically does a <<mongodump>> and then a <<mongorestore>>, making a clean copy of your data and, in the process, removing any empty <<holes>> in your data files. (When you do a lot of deletes or updates that move things around, large parts of your collection could be sitting around empty.) repair re-inserts everything in a compact form.\cite{mongodb_tips}

\subsection{Always use replication, journaling, or both}

If you’re running a single server, use the <<--journal>> option.

Given the performance penalties involved in using journaling, you might want to mix journaled an unjournaled servers if you have multiple machines. Backup slaves could be journaled, whereas primaries and secondaries (especially those balancing read load) could be unjournaled.\cite{mongodb_tips}

\section{Use cases}

\begin{itemize}
  \item Where need ORDBMS (object-relational database management system), but you don't have clear structure of the tables (you need shema-less)
  \item Storing Log Data
  \item Cache Storage
  \item Analytics
\end{itemize}